diff --git a/node_modules/@parcel/packager-js/lib/dev-prelude.js b/node_modules/@parcel/packager-js/lib/dev-prelude.js
index 5636da4..fbce339 100644
--- a/node_modules/@parcel/packager-js/lib/dev-prelude.js
+++ b/node_modules/@parcel/packager-js/lib/dev-prelude.js
@@ -1,11 +1,3 @@
-// modules are defined as an array
-// [ module function, map of requires ]
-//
-// map of requires is short require name -> numeric require
-//
-// anything defined in a previous bundle is accessed via the
-// orig method which is the require for previous bundles
-
 (function (modules, entry, mainEntry, parcelRequireName, globalName) {
   /* eslint-disable no-undef */
   var globalObject =
@@ -141,5 +133,6 @@
     } else if (globalName) {
       this[globalName] = mainExports;
     }
+    return mainExports.default;
   }
 });
diff --git a/node_modules/@parcel/packager-js/lib/helpers.js b/node_modules/@parcel/packager-js/lib/helpers.js
index c222e63..09426d6 100644
--- a/node_modules/@parcel/packager-js/lib/helpers.js
+++ b/node_modules/@parcel/packager-js/lib/helpers.js
@@ -36,7 +36,7 @@ if (parcelRequire == null) {
 exports.prelude = prelude;
 const helpers = {
   $parcel$export: `function $parcel$export(e, n, v, s) {
-  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
+  var r=v();r&&"register"!==n&&"resolve"!==n&&"getBundleURL"!==n?e[n]=r:e[n]=v;
 }
 `,
   $parcel$exportWildcard: `function $parcel$exportWildcard(dest, source) {
@@ -57,7 +57,7 @@ const helpers = {
 }
 `,
   $parcel$interopDefault: `function $parcel$interopDefault(a) {
-  return a && a.__esModule ? a.default : a;
+  return a && a.__esModule ? a["default"] : a;
 }
 `,
   $parcel$global: `var $parcel$global =
diff --git a/node_modules/@parcel/packager-js/lib/index.js b/node_modules/@parcel/packager-js/lib/index.js
index cf5a98b..2a7f49c 100644
--- a/node_modules/@parcel/packager-js/lib/index.js
+++ b/node_modules/@parcel/packager-js/lib/index.js
@@ -81,11 +81,23 @@ var _default = new (_plugin().Packager)({
         map
       } = await packager.package());
     }
-    contents += '\n' + (await getSourceMapSuffix(getSourceMapReference, map));
+
+    if (bundle.env.shouldScopeHoist) {
+      const exportedIdentifiers = contents.match(/var \$[0-9a-f]{16}\$export\$[0-9a-f]+ = /g);
+      if (exportedIdentifiers) {
+        const lastExportedIdentifier = exportedIdentifiers[exportedIdentifiers.length - 1].slice(4).slice(0, -3);
+        const functionCloseIndex = contents.lastIndexOf('}');
+        contents = contents.substring(0, functionCloseIndex) + `return ${lastExportedIdentifier};` + contents.substring(functionCloseIndex);
+      }
+    }
+
+    let sourceMapDir = bundle.target.publicUrl + _path().default.dirname(bundle.name).replaceAll(_path().default.sep, "/").replace(/^\.\//, '');
+    sourceMapDir += sourceMapDir.endsWith('/') ? '' : '/';
+    contents += '\n' + (await getSourceMapSuffix(getSourceMapReference, map, sourceMapDir));
 
     // For library builds, we need to replace URL references with their final resolved paths.
     // For non-library builds, this is handled in the JS runtime.
-    if (bundle.env.isLibrary) {
+    // if (bundle.env.isLibrary) {
       ({
         contents,
         map
@@ -96,7 +108,7 @@ var _default = new (_plugin().Packager)({
         map,
         getReplacement: s => JSON.stringify(s).slice(1, -1)
       }));
-    }
+    // }
     return (0, _utils().replaceInlineReferences)({
       bundle,
       bundleGraph,
@@ -111,10 +123,10 @@ var _default = new (_plugin().Packager)({
   }
 });
 exports.default = _default;
-async function getSourceMapSuffix(getSourceMapReference, map) {
+async function getSourceMapSuffix(getSourceMapReference, map, sourceMapDir) {
   let sourcemapReference = await getSourceMapReference(map);
   if (sourcemapReference != null) {
-    return '//# sourceMappingURL=' + sourcemapReference + '\n';
+    return '//# sourceMappingURL=' + sourceMapDir + sourcemapReference + '\n';
   } else {
     return '';
   }
